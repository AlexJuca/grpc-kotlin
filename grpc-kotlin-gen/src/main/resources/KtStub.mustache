{{#packageName}}
package {{packageName}};
{{/packageName}}

import {{packageName}}.{{serviceName}}Grpc.*

import io.grpc.BindableService
import io.grpc.CallOptions
import io.grpc.Channel
import io.grpc.ServerServiceDefinition
import io.grpc.stub.AbstractStub
import io.grpc.stub.ServerCalls
import io.grpc.stub.StreamObserver

import kotlinx.coroutines.experimental.CompletableDeferred
import kotlinx.coroutines.experimental.Deferred
import kotlinx.coroutines.experimental.GlobalScope
import kotlinx.coroutines.experimental.channels.Channel as KtChannel
import kotlinx.coroutines.experimental.channels.ReceiveChannel
import kotlinx.coroutines.experimental.channels.SendChannel
import kotlinx.coroutines.experimental.launch

{{#deprecated}}@Deprecated("deprecated"){{/deprecated}}
@javax.annotation.Generated(
    value = ["by gRPC Kotlin generator"],
    comments = "Source: {{protoName}}"
)
object {{className}} {

    /**
     * Creates a new coroutine stub that supports all call types for the service
     */
    @JvmStatic
    fun newStub(channel: Channel): {{serviceName}}KtStub {
        return {{serviceName}}KtStub(channel)
    }

    class {{serviceName}}KtStub : AbstractStub<{{serviceName}}KtStub> {

        private val delegate: {{packageName}}.{{serviceName}}Grpc.{{serviceName}}Stub

        internal constructor(channel: Channel) : super(channel) {
            delegate = {{packageName}}.{{serviceName}}Grpc.newStub(channel)
        }

        internal constructor(channel: Channel, callOptions: CallOptions) : super(channel, callOptions) {
            delegate = {{packageName}}.{{serviceName}}Grpc.newStub(channel).build(channel, callOptions)
        }

        override fun build(channel: Channel, callOptions: CallOptions): {{serviceName}}KtStub {
            return {{serviceName}}KtStub(channel, callOptions)
        }

        {{#methods}}
        {{#javaDoc}}{{{javaDoc}}}{{/javaDoc}}
        {{#deprecated}}@Deprecated("deprecated"){{/deprecated}}
        {{^isManyInput}}
        {{^isManyOutput}}
        {{! == unary req, unary resp == }}
        fun {{methodName}}(request: {{inputType}}): Deferred<{{outputType}}> {
            val responseDeferred = StreamObserverDeferred<{{outputType}}>()
            delegate.{{methodName}}(request, responseDeferred)
            return responseDeferred
        }
        {{/isManyOutput}}
        {{#isManyOutput}}
        {{! == unary req, streaming resp == }}
        fun {{methodName}}(request: {{inputType}}): ReceiveChannel<{{outputType}}> {
            val responseChannel = StreamObserverChannel<{{outputType}}>()
            delegate.{{methodName}}(request, responseChannel)
            return responseChannel
        }
        {{/isManyOutput}}
        {{/isManyInput}}
        {{#isManyInput}}
        {{^isManyOutput}}
        {{! == streaming req, unary resp == }}
        fun {{methodName}}(): ManyToOneCall<{{inputType}}, {{outputType}}> {
            val responseDeferred = StreamObserverDeferred<{{outputType}}>()
            val requestObserver = delegate.{{methodName}}(responseDeferred)
            val requestChannel = KtChannel<{{inputType}}>(KtChannel.UNLIMITED)
            connectChannelToObserver(requestChannel, requestObserver)
            return ManyToOneCall(requestChannel, responseDeferred)
        }
        {{/isManyOutput}}
        {{#isManyOutput}}
        {{! == streaming req, streaming resp == }}
        fun {{methodName}}(): ManyToManyCall<{{inputType}}, {{outputType}}> {
            val responseChannel = StreamObserverChannel<{{outputType}}>()
            val requestObserver = delegate.{{methodName}}(responseChannel)
            val requestChannel = KtChannel<{{inputType}}>(KtChannel.UNLIMITED)
            connectChannelToObserver(requestChannel, requestObserver)
            return ManyToManyCall(requestChannel, responseChannel)
        }
        {{/isManyOutput}}
        {{/isManyInput}}
        {{/methods}}
    }

    {{#javaDoc}}{{{javaDoc}}}{{/javaDoc}}
    abstract class {{serviceName}}ImplBase : BindableService {

        {{#methods}}
        {{#javaDoc}}{{{javaDoc}}}{{/javaDoc}}
        {{#deprecated}}@Deprecated("deprecated"){{/deprecated}}
        {{^isManyInput}}
        {{^isManyOutput}}
        {{! == unary req, unary resp == }}
        open fun {{methodName}}(request: {{inputType}}): Deferred<{{outputType}}> {
            throw io.grpc.StatusRuntimeException(io.grpc.Status.UNIMPLEMENTED)
        }

        internal fun {{methodName}}Internal(
            request: {{inputType}},
            responseObserver: StreamObserver<{{outputType}}>
        ) {
            val responseDeferred = {{methodName}}(request)
            connectDeferredToObserver(responseDeferred, responseObserver)
        }
        {{/isManyOutput}}
        {{#isManyOutput}}
        {{! == unary req, streaming resp == }}
        open fun {{methodName}}(request: {{inputType}}): ReceiveChannel<{{outputType}}> {
            throw io.grpc.StatusRuntimeException(io.grpc.Status.UNIMPLEMENTED)
        }

        internal fun {{methodName}}Internal(
            request: {{inputType}},
            responseObserver: StreamObserver<{{outputType}}>
        ) {
            val responseChannel = {{methodName}}(request)
            connectChannelToObserver(responseChannel, responseObserver)
        }
        {{/isManyOutput}}
        {{/isManyInput}}
        {{#isManyInput}}
        {{^isManyOutput}}
        {{! == streaming req, unary resp == }}
        open fun {{methodName}}(requestChannel: ReceiveChannel<{{inputType}}>): Deferred<{{outputType}}> {
            throw io.grpc.StatusRuntimeException(io.grpc.Status.UNIMPLEMENTED)
        }

        internal fun {{methodName}}Internal(
            responseObserver: StreamObserver<{{outputType}}>
        ): StreamObserver<{{inputType}}> {
            val requestChannel = StreamObserverChannel<{{inputType}}>()
            val responseDeferred = {{methodName}}(requestChannel)
            connectDeferredToObserver(responseDeferred, responseObserver)
            return requestChannel
        }
        {{/isManyOutput}}
        {{#isManyOutput}}
        {{! == streaming req, streaming resp == }}
        open fun {{methodName}}(requestChannel: ReceiveChannel<{{inputType}}>): ReceiveChannel<{{outputType}}> {
            throw io.grpc.StatusRuntimeException(io.grpc.Status.UNIMPLEMENTED)
        }

        internal fun {{methodName}}Internal(
            responseObserver: StreamObserver<{{outputType}}>
        ): StreamObserver<{{inputType}}> {
            val requestChannel = StreamObserverChannel<{{inputType}}>()
            val responseChannel = {{methodName}}(requestChannel)
            connectChannelToObserver(responseChannel, responseObserver)
            return requestChannel
        }
        {{/isManyOutput}}
        {{/isManyInput}}
        {{/methods}}

        override fun bindService(): ServerServiceDefinition {
            return ServerServiceDefinition.builder(getServiceDescriptor())
                {{#methods}}
                .addMethod(
                    get{{methodNamePascalCase}}Method(),
                    ServerCalls.{{grpcCallsMethodName}}(
                        MethodHandlers(this, METHODID_{{methodNameUpperUnderscore}})
                    )
                )
                {{/methods}}
                .build()
        }
    }

    private fun <E> connectChannelToObserver(channel: ReceiveChannel<E>, observer: StreamObserver<E>) {
        // todo: specify coroutine context
        GlobalScope.launch {
            try {
                for (value in channel) {
                    observer.onNext(value)
                }
                observer.onCompleted()
            } catch (t: Throwable) {
                observer.onError(t)
            }
        }
    }

    private fun <E> connectDeferredToObserver(deferred: Deferred<E>, observer: StreamObserver<E>) {
        // todo: specify coroutine context
        GlobalScope.launch {
            try {
                observer.onNext(deferred.await())
                observer.onCompleted()
            } catch (t: Throwable) {
                observer.onError(t)
            }
        }
    }

    data class ManyToOneCall<in TRequest, out TResponse>(
        val request: SendChannel<TRequest>,
        val response: Deferred<TResponse>
    )

    data class ManyToManyCall<in TRequest, out TResponse>(
        val request: SendChannel<TRequest>,
        val response: ReceiveChannel<TResponse>
    )

    private class StreamObserverDeferred<E>
        : StreamObserver<E>, CompletableDeferred<E> by CompletableDeferred() {

        override fun onNext(value: E) { complete(value) }
        override fun onError(t: Throwable) { cancel(t) }
        override fun onCompleted() { /* nothing */ }
    }

    private class StreamObserverChannel<E>
        : KtChannel<E> by KtChannel<E>(KtChannel.UNLIMITED), StreamObserver<E> {

        override fun onNext(value: E) { offer(value) }
        override fun onError(t: Throwable?) { close(cause = t) }
        override fun onCompleted() { close(cause = null) }
    }

    {{#methods}}
    val METHODID_{{methodNameUpperUnderscore}} = {{methodNumber}}
    {{/methods}}

    private class MethodHandlers<Req, Resp> internal constructor(
        private val serviceImpl: {{serviceName}}ImplBase,
        private val methodId: Int
    ) : ServerCalls.UnaryMethod<Req, Resp>,
        ServerCalls.ServerStreamingMethod<Req, Resp>,
        ServerCalls.ClientStreamingMethod<Req, Resp>,
        ServerCalls.BidiStreamingMethod<Req, Resp> {

        @Suppress("UNCHECKED_CAST")
        override fun invoke(request: Req, responseObserver: StreamObserver<Resp>) {
            when (methodId) {
                {{#methods}}
                {{^isManyInput}}
                METHODID_{{methodNameUpperUnderscore}} ->
                    serviceImpl.{{methodName}}Internal(
                        request as {{inputType}},
                        responseObserver as StreamObserver<{{outputType}}>
                    )
                {{/isManyInput}}
                {{/methods}}
                else -> throw AssertionError()
            }
        }

        @Suppress("UNCHECKED_CAST")
        override fun invoke(responseObserver: StreamObserver<Resp>): StreamObserver<Req> {
            return when (methodId) {
                {{#methods}}
                {{#isManyInput}}
                METHODID_{{methodNameUpperUnderscore}} ->
                    serviceImpl.{{methodName}}Internal(
                        responseObserver as StreamObserver<{{outputType}}>
                    ) as StreamObserver<Req>
                {{/isManyInput}}
                {{/methods}}
                else -> throw AssertionError()
            }
        }
    }
}
